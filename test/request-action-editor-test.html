<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../request-action-editor.html">
  </head>
  <body>
    <test-fixture id="basic">
      <template>
        <request-action-editor></request-action-editor>
      </template>
    </test-fixture>

    <script>
    suite('basic', function() {
      const config = {
        source: 'response.headers.content-type',
        action: 'assign-variable',
        destination: 'someValue',
        enabled: true,
        conditions: [{
          source: 'response.status',
          operator: 'equal',
          condition: 200,
          enabled: true
        }]
      };
      let element;
      setup(function() {
        element = fixture('basic');
        element.action = Object.assign({}, config);
      });

      test('source is computed', function() {
        assert.equal(element.source, 'response');
      });

      test('sourceType is computed', function() {
        assert.equal(element.sourceType, 'headers');
      });

      test('sourcePath is computed', function() {
        assert.equal(element.sourcePath, 'content-type');
      });

      test('_cancelSourceProcessing is not set', function() {
        assert.isFalse(element._cancelSourceProcessing);
      });

      test('Updates condition.source', function() {
        element.source = 'request';
        element.sourceType = 'url';
        element.sourcePath = 'query';
        assert.equal(element.action.source, 'request.url.query');
      });

      test('source path input is visible', function() {
        const elm = element.shadowRoot.querySelector('.source-path');
        const style = getComputedStyle(elm);
        assert.notEqual(style.display, 'none');
      });

      test('Hides source path input', function() {
        element.sourceType = 'status';
        const elm = element.shadowRoot.querySelector('.source-path');
        const style = getComputedStyle(elm);
        assert.equal(style.display, 'none');
      });

      test('Enable button is not rendered', function(done) {
        flush(() => {
          const elm = element.shadowRoot.querySelector('.action-enabler');
          assert.notOk(elm);
          done();
        });
      });

      test('Info label is rendered', function(done) {
        flush(() => {
          const elm = element.shadowRoot.querySelector('.short-info');
          assert.ok(elm);
          done();
        });
      });

      test('Renders conditions', function(done) {
        flush(() => {
          const elm = element.shadowRoot.querySelector('request-condition-editor');
          assert.ok(elm);
          done();
        });
      });

      test('Adds condition on button click', function() {
        assert.lengthOf(element.action.conditions, 1);
        const button = element.shadowRoot.querySelector('.add-condition');
        button.click();
        assert.lengthOf(element.action.conditions, 2);
      });
    });

    suite('_computeToglePanelLabel()', function() {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Label for opened', function() {
        const result = element._computeToglePanelLabel(true);
        assert.equal(result, 'Hide editor');
      });

      test('Label for not opened', function() {
        const result = element._computeToglePanelLabel(false);
        assert.equal(result, 'Show editor');
      });
    });

    suite('_computeActionStateLabel()', function() {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Label for enabled', function() {
        const result = element._computeActionStateLabel(true);
        assert.equal(result, 'enabled');
      });

      test('Label for not enabled', function() {
        const result = element._computeActionStateLabel(false);
        assert.equal(result, 'disabled');
      });
    });

    suite('_computePathHidden()', function() {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Returns true for status', function() {
        const result = element._computePathHidden('status');
        assert.isTrue(result);
      });

      test('Returns false for other types', function() {
        assert.isFalse(element._computePathHidden('url'));
        assert.isFalse(element._computePathHidden('headers'));
        assert.isFalse(element._computePathHidden('body'));
      });
    });

    suite('_computeActionLabel()', function() {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Return value for assign-variable', function() {
        const result = element._computeActionLabel('assign-variable');
        assert.equal(result, 'Assign variable');
      });

      test('Return value for other types', function() {
        assert.equal(element._computeActionLabel('store-variable'), 'Store variable');
      });
    });

    suite('addCondition()', function() {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Adds condition with default values', function() {
        element.addCondition();
        const c = element.action.conditions[0];
        assert.equal(c.source, 'response.status');
        assert.equal(c.operator, 'equal');
        assert.equal(c.condition, 200);
        assert.isTrue(c.enabled);
      });

      test('Adds condition with predefined values', function() {
        const data = {
          source: 'request.url',
          operator: 'contains',
          condition: 'test',
          enabled: false
        };
        element.addCondition(data);
        const c = element.action.conditions[0];
        assert.equal(c.source, data.source);
        assert.equal(c.operator, data.operator);
        assert.equal(c.condition, data.condition);
        assert.equal(c.enabled, data.enabled);
      });
    });

    suite('Delete action', function() {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Dispatches remove-action-item custom event', function() {
        const spy = sinon.spy();
        element.addEventListener('remove-action-item', spy);
        const button = element.shadowRoot.querySelector('.remove-action');
        button.click();
        assert.isTrue(spy.calledOnce);
      });

      test('remove-action-item custom event does not bubble', function(done) {
        element.addEventListener('remove-action-item', function clb(e) {
          element.removeEventListener('remove-action-item', clb);
          assert.isFalse(e.bubbles);
          done();
        });
        element.remove();
      });
    });

    suite('_removeCondition()', function() {
      let element;
      setup(function(done) {
        element = fixture('basic');
        element.action = {
          source: 'response.headers.content-type',
          action: 'assign-variable',
          destination: 'someValue',
          enabled: true,
          conditions: [{
            source: 'response.status',
            operator: 'equal',
            condition: 200,
            enabled: true
          }]
        };
        flush(() => done());
      });

      test('Removes condition from the list', function() {
        const editor = element.shadowRoot.querySelector('request-condition-editor');
        editor.remove();
        assert.lengthOf(element.action.conditions, 0);
      });

      test('Removes element from the dom', function(done) {
        const editor = element.shadowRoot.querySelector('request-condition-editor');
        editor.remove();
        flush(() => {
          const editor = element.shadowRoot.querySelector('request-condition-editor');
          assert.notOk(editor);
          done();
        });
      });
    });

    suite('Iterable editor', function() {
      let element;
      setup(function(done) {
        element = fixture('basic');
        element.action = {
          source: 'response.body.value',
          action: 'assign-variable',
          destination: 'someValue',
          enabled: true
        };
        flush(() => done());
      });

      test('Computes _renderIterator', function() {
        assert.isTrue(element._renderIterator);
      });

      test('action.hasIterator is undefined', function() {
        assert.isUndefined(element.action.hasIterator);
      });

      test('Hiddes the iterator toggle button', function(done) {
        element.sourceType = 'headers';
        flush(() => {
          assert.isFalse(element._renderIterator);
          const toggle = element.shadowRoot.querySelector('.iterator-enabler');
          const style = getComputedStyle(toggle);
          assert.equal(style.display, 'none');
          done();
        });
      });

      test('Renders iterable editor', function(done) {
        const toggle = element.shadowRoot.querySelector('[data-action="iterable-toggle"]');
        toggle.click();
        flush(() => {
          const editor = element.shadowRoot.querySelector('request-action-iterator-editor');
          assert.ok(editor);
          done();
        });
      });

      test('Creates default values', function() {
        element.set('action.hasIterator', true);
        assert.equal(element.action.iterator.source, 'data.*.property');
        assert.equal(element.action.iterator.operator, 'equal');
      });
    });
    </script>
  </body>
</html>
